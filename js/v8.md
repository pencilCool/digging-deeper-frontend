### 利用v8写出优化代码
How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code
https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e

V8 最初旨在提高 Web 浏览器中 JavaScript 执行的性能。 为了获得速度，V8 将 JavaScript 代码翻译成更高效的机器代码，而不是使用解释器。 它通过像许多现代 JavaScript 引擎（例如 SpiderMonkey 或 Rhino (Mozilla)）那样实现 JIT（即时）编译器，在执行时将 JavaScript 代码编译成机器代码。 这里的主要区别在于 V8 不生成字节码或任何中间代码。

### V8 曾经有两个编译器 
在 V8 5.9 版问世之前，该引擎使用了两个编译器：
- full-codegen:一个简单且非常快速的编译器，可以生成简单且相对较慢的机器代码。
- Crankshaft:一种更复杂的（即时）优化编译器，可生成高度优化的代码。
V8 引擎在内部也使用了几个线程：
- 主线程：获取你的代码，编译它然后执行它
- 编译线程:编译线程同时优化代码
- Profiler 线程:它将告诉运行时我们在哪些方法上花费了很多时间，以便 Crankshaft 可以优化它们
- 处理垃圾收集器扫描的几个线程

在第一次执行 JavaScript 代码时，V8 使用 full-codegen 直接将解析后的 JavaScript 转换为机器码，无需任何转换。 这允许它非常快速地开始执行机器代码。 请注意，V8 不使用中间字节码表示，从而无需解释器。
当您的代码运行了一段时间后，分析器线程已经收集到足够的数据来判断应该优化哪个方法。
接下来，Crankshaft 优化从另一个线程开始。 它将 JavaScript 抽象语法树转换为称为 Hydrogen (high-level static single-assignment (SSA))，并尝试优化该 Hydrogen。 大多数优化都是在这个级别完成的。

### 内联
第一个优化是提前内联尽可能多的代码。 内联是用被调用函数的主体替换调用站点（调用函数的代码行）的过程。 这个简单的步骤允许以下优化更有意义。

### 
JavaScript 是一种基于原型的语言：没有类,对象是使用克隆创建的。 JavaScript 也是一种动态编程语言，这意味着可以在对象实例化后轻松地从对象中添加或删除属性。
大多数 JavaScript 解释器使用类似字典的结构（基于散列函数）来存储对象属性值在内存中的位置。与在 Java 或 C# 等非动态编程语言中相比，这种结构使得在 JavaScript 中检索属性值的计算成本更高。在 Java 中，所有对象属性在编译前由固定的对象布局确定，不能在运行时动态添加或删除。因此，属性的值（或指向这些属性的指针）可以作为连续缓冲区存储在内存中，每个缓冲区之间具有固定偏移量。偏移量的长度可以很容易地根据属性类型确定，而这在 JavaScript 中是不可能的，因为 JavaScript 中的属性类型可以在运行时更改。
由于使用字典在内存中查找对象属性的位置非常低效，因此 V8 使用了不同的方法：隐藏类。隐藏类的工作方式类似于 Java 等语言中使用的固定对象布局（类），除了它们是在运行时创建的。现在，让我们看看它们的实际外观：

```
function Point(x, y) {
    this.x = x;
    this.y = y;
}
var p1 = new Point(1, 2);

```

一旦“new Point(1, 2)”调用发生，V8 将创建一个名为“C0”的隐藏类。 

尚未为 Point 定义任何属性，因此“C0”为空。
一旦执行了第一条语句“this.x = x”（在“Point”函数内），V8 将创建第二个名为“C1”的隐藏类，它基于“C0”。 “C1”描述了可以找到属性 x 的内存位置（相对于对象指针）。 在这种情况下，“x”存储在偏移量 0 处，这意味着当将内存中的点对象视为连续缓冲区时，第一个偏移量将对应于属性“x”。 V8 还将使用“类转换”更新“C0”，它指出如果将属性“x”添加到点对象，隐藏类应该从“C0”切换到“C1”。 下面点对象的隐藏类现在是“C1”。


当执行语句“this.y = y”时（再次在 Point 函数内部，在“this.x = x”语句之后）重复此过程。
创建了一个名为“C2”的新隐藏类，将一个类转换添加到“C1”，说明如果将属性“y”添加到 Point 对象（已包含属性“x”），则隐藏类应更改为 “C2”，点对象的隐藏类更新为“C2”。


隐藏的类转换取决于属性添加到对象的顺序。 看看下面的代码片段


```
function Point(x, y) {
    this.x = x;
    this.y = y;
}
var p1 = new Point(1, 2);
p1.a = 5;
p1.b = 6;

```

现在，您会假设对于 p1 和 p2 都将使用相同的隐藏类和转换。 嗯，不是真的。 对于“p1”，首先将添加属性“a”，然后添加属性“b”。 然而，对于“p2”，首先分配的是“b”，然后是“a”。 因此，由于不同的转换路径，“p1”和“p2”最终具有不同的隐藏类。 在这种情况下，最好以相同的顺序初始化动态属性，以便可以重用隐藏的类。

### 内联缓存
V8 利用了另一种技术来优化动态类型语言，称为内联缓存。内联缓存依赖于对同一方法的重复调用往往发生在同一类型的对象上的观察。可以在此处找到对内联缓存的深入解释。
我们将讨论内联缓存的一般概念。
那么它是怎样工作的？ V8 维护了在最近的方法调用中作为参数传递的对象类型的缓存，并使用此信息来假设将来将作为参数传递的对象类型。如果 V8 能够对将传递给方法的对象类型做出很好的假设，它可以绕过计算如何访问对象属性的过程，而是使用之前查找对象的存储信息隐藏类。
那么隐藏类和内联缓存的概念是如何相关的呢？每当在特定对象上调用方法时，V8 引擎必须对该对象的隐藏类执行查找，以确定访问特定属性的偏移量。在对同一个隐藏类两次成功调用相同方法后，V8 省略了隐藏类查找，只是简单地将属性的偏移量添加到对象指针本身。对于该方法的所有未来调用，V8 引擎假定隐藏类没有更改，并使用先前查找中存储的偏移量直接跳转到特定属性的内存地址。这大大提高了执行速度。
内联缓存也是相同类型的对象共享隐藏类如此重要的原因。如果你创建了两个相同类型且具有不同隐藏类的对象（正如我们在前面的示例中所做的那样），V8 将无法使用内联缓存，因为即使这两个对象属于相同类型，它们对应的隐藏类为其属性分配不同的偏移量。


### 编译成机器码
Hydrogen图优化后，Crankshaft将其降低到称为锂的较低级别表示:Lithium。大多数Lithium实现是特定于架构的。寄存器分配发生在这个级别。
最后，Lithium被编译成机器码。然后发生了其他事情，称为 OSR：堆栈替换。在我们开始编译和优化一个明显长时间运行的方法之前，我们很可能正在运行它。 V8 不会忘记它刚刚慢慢执行的内容，以重新开始优化版本。相反，它将转换我们拥有的所有上下文（堆栈、寄存器），以便我们可以在执行过程中切换到优化版本。这是一项非常复杂的任务，请记住，在其他优化中，V8 最初已经内联了代码。 V8 并不是唯一能够做到这一点的引擎。
有一种称为去优化的保护措施可以进行相反的转换并恢复到未优化的代码，以防引擎做出的假设不再成立。 

### 垃圾收集 
对于垃圾收集，V8 使用传统的标记和清除方法来清理老年代。 标记阶段应该停止 JavaScript 执行。 为了控制 GC 成本并使执行更稳定，V8 使用增量标记：不是遍历整个堆，而是尝试标记每个可能的对象，它只遍历堆的一部分，然后恢复正常执行。 下一次 GC 停止将从上一次堆遍历停止的位置继续。 这允许在正常执行期间非常短的暂停。 如前所述，扫描阶段由单独的线程处理。 

### 点火和涡轮风扇
随着 2017 年初 V8 5.9 的发布，引入了新的执行管道。 这个新管道在实际 JavaScript 应用程序中实现了更大的性能改进和显着的内存节省。
新的执行管道建立在 V8 的解释器 Ignition 和 V8 最新的优化编译器 TurboFan 之上。
您可以在此处查看 V8 团队关于该主题的博客文章。
自 V8 5.9 版发布以来，V8 不再使用 full-codegen 和 Crankshaft（自 2010 年以来服务于 V8 的技术）来执行 JavaScript，因为 V8 团队一直在努力跟上新的 JavaScript 语言特性和 这些功能所需的优化。
这意味着整个 V8 将拥有更简单、更易于维护的架构。

这些改进仅仅是开始。新的 Ignition 和 TurboFan 管道为进一步优化铺平了道路，这将在未来几年提高 JavaScript 性能并缩小 V8 在 Chrome 和 Node.js 中的占用空间。

### 摘要：如何编写优化的 JavaScript
1. 对象属性的顺序：始终以相同的顺序实例化您的对象属性，以便可以共享隐藏的类以及随后优化的代码。

2. 动态属性：实例化后向对象添加属性将强制更改隐藏类并减慢为先前隐藏类优化的任何方法。相反，在其构造函数中分配对象的所有属性。

3. 方法：重复执行相同方法的代码将比只执行许多不同方法的代码运行得更快（由于内联缓存）。

4. 数组：避免键不是增量数字的稀疏数组。里面没有每个元素的稀疏数组是一个哈希表。此类数组中的元素访问成本更高。另外，尽量避免预先分配大数组。最好是随着你的成长而成长。最后，不要删除数组中的元素。它使键稀疏。

5. 标记值：V8 用 32 位表示对象和数字。它使用位来知道它是对象（标志 = 1）还是整数（标志 = 0），称为 SMI（SMall Integer），因为它有 31 位。然后，如果一个数值大于 31 位，V8 将把这个数字装箱，把它变成一个 double 并创建一个新的对象来把这个数字放进去。尽可能尝试使用 31 位有符号数字，以避免对 JS 对象进行昂贵的装箱操作。

